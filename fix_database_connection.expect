#!/usr/bin/expect -f

set timeout 30
spawn ssh -o StrictHostKeyChecking=no -o PreferredAuthentications=password root@31.97.28.231

expect {
    "password:" {
        send "62uDLW4RJ9ae28EPVfp5yzT##\r"
        exp_continue
    }
    "# " {
        send "cd /root/eon\r"
        expect "# "

        # Check the actual SQLite database with data
        send "echo '=== CHECKING ACTUAL SQLITE DATABASE WITH DATA ==='\r"
        expect "# "
        send "sqlite3 server/database.sqlite '.tables'\r"
        expect "# "

        # Check users in the actual database
        send "echo '\\n=== CHECKING USERS IN ACTUAL DATABASE ==='\r"
        expect "# "
        send "sqlite3 server/database.sqlite 'SELECT id, email, role, status FROM users;'\r"
        expect "# "

        # Check if teste@iaeon.com exists in actual database
        send "echo '\\n=== CHECKING TEST USER IN ACTUAL DATABASE ==='\r"
        expect "# "
        send "sqlite3 server/database.sqlite \"SELECT id, email, password_hash, role, status FROM users WHERE email = 'teste@iaeon.com';\"\r"
        expect "# "

        # The issue is the connection.js file is using wrong database path
        # Let's check the connection.js file again
        send "echo '\\n=== CHECKING CONNECTION.JS FILE ==='\r"
        expect "# "
        send "cat server/database/connection.js | head -10\r"
        expect "# "

        # Since PostgreSQL ENV vars are set but likely not working, let's disable them temporarily
        send "echo '\\n=== TEMPORARILY DISABLING POSTGRESQL ENV VARS ==='\r"
        expect "# "
        send "cp .env .env.backup\r"
        expect "# "

        # Comment out DATABASE_URL and DB_HOST to force SQLite usage
        send "sed -i 's/^DATABASE_URL=/#DATABASE_URL=/' .env\r"
        expect "# "
        send "sed -i 's/^DB_HOST=/#DB_HOST=/' .env\r"
        expect "# "

        # Verify environment changes
        send "echo '\\n=== CHECKING MODIFIED ENV FILE ==='\r"
        expect "# "
        send "grep -E '(DATABASE_URL|DB_HOST)' .env\r"
        expect "# "

        # Restart the server to pick up new environment
        send "echo '\\n=== RESTARTING SERVER WITH NEW ENVIRONMENT ==='\r"
        expect "# "
        send "pm2 restart iaeon-server\r"
        expect "# "

        # Wait for server to restart
        send "sleep 3\r"
        expect "# "

        # Check server status
        send "echo '\\n=== CHECKING SERVER STATUS ==='\r"
        expect "# "
        send "pm2 status iaeon-server\r"
        expect "# "

        # Check recent logs
        send "echo '\\n=== CHECKING RECENT LOGS ==='\r"
        expect "# "
        send "pm2 logs iaeon-server --lines 5 --nostream\r"
        expect "# "

        # Test login now
        send "echo '\\n=== TESTING LOGIN AFTER DATABASE FIX ==='\r"
        expect "# "
        send "curl -X POST http://localhost:5001/api/auth/login -H \"Content-Type: application/json\" -d '{\"email\":\"teste@iaeon.com\",\"password\":\"123456\"}' -s\r"
        expect "# "

        # If that doesn't work, let's create the correct user with proper hash
        send "echo '\\n=== CREATING CORRECT USER IF NEEDED ==='\r"
        expect "# "
        send "cat > /tmp/create_test_user.js << 'EOF'
const bcrypt = require('bcryptjs');
const sqlite3 = require('sqlite3').verbose();

async function createTestUser() {
    const db = new sqlite3.Database('/root/eon/server/database.sqlite');

    const email = 'teste@iaeon.com';
    const password = '123456';
    const name = 'Test User';
    const role = 'admin';
    const status = 'active';

    try {
        // Generate correct bcrypt hash
        const passwordHash = await bcrypt.hash(password, 12);
        console.log('Generated hash:', passwordHash);

        // Check if user exists
        db.get('SELECT id FROM users WHERE email = ?', [email], (err, user) => {
            if (err) {
                console.error('Error checking user:', err);
                db.close();
                return;
            }

            if (user) {
                // Update existing user
                console.log('Updating existing user...');
                db.run(
                    'UPDATE users SET password_hash = ?, name = ?, role = ?, status = ? WHERE email = ?',
                    [passwordHash, name, role, status, email],
                    function(err) {
                        if (err) {
                            console.error('Error updating user:', err);
                        } else {
                            console.log('✅ User updated successfully');
                        }
                        db.close();
                    }
                );
            } else {
                // Create new user
                console.log('Creating new user...');
                db.run(
                    'INSERT INTO users (email, password_hash, name, role, status, created_at) VALUES (?, ?, ?, ?, ?, datetime(\"now\"))',
                    [email, passwordHash, name, role, status],
                    function(err) {
                        if (err) {
                            console.error('Error creating user:', err);
                        } else {
                            console.log('✅ User created successfully with ID:', this.lastID);
                        }
                        db.close();
                    }
                );
            }
        });
    } catch (error) {
        console.error('Error generating hash:', error);
        db.close();
    }
}

createTestUser();
EOF\r"
        expect "# "

        # Run user creation script
        send "echo '\\n=== RUNNING USER CREATION SCRIPT ==='\r"
        expect "# "
        send "node /tmp/create_test_user.js\r"
        expect "# "

        # Wait for async operation
        send "sleep 3\r"
        expect "# "

        # Test login again
        send "echo '\\n=== TESTING LOGIN AFTER USER CREATION ==='\r"
        expect "# "
        send "curl -X POST http://localhost:5001/api/auth/login -H \"Content-Type: application/json\" -d '{\"email\":\"teste@iaeon.com\",\"password\":\"123456\"}' -s | jq .\r"
        expect "# "

        send "exit\r"
    }
    timeout {
        puts "Connection timeout"
        exit 1
    }
}

expect eof